---
title: "Header mismatch / wrong header row when using pd.read_excel"
description: "Why reading Excel files with an unexpected header location causes missing columns, wrong column names, or parsing errors and how to fix it using `header` and `skiprows`."
date: 2025-12-07
tags: ["python", "pandas", "errors"]
---

## Header mismatch / Wrong header row when using `pd.read_excel`

```bash
$ python - << 'PY'
import pandas as pd

# Suppose an Excel file has a header on the second row (row 1, zero-index)
# If you read it with the default header=0 you'd get the first row as header instead
# leading to missing columns or wrong column names when accessing them
try:
    df = pd.read_excel('file.xlsx')  # header mismatch if the header is not on row 0
    print(df.columns)
except Exception as e:
    print(type(e).__name__ + ':', e)
PY
```

### Why this happens

Pandas' `read_excel` tries to guess the header row by default (`header=0`). If the header in your spreadsheet is actually on another row — or you have multi-row headers — the columns will be misread (for example, actual column names are part of the first data row). This can cause `KeyError` later when you try to access expected columns, or an extra index column like `Unnamed: 0` appears.

### Fix

- Use the `header` argument to specify the exact header row(s) (zero-based). `header=0` is default; if your column names are on the second row, use `header=1`.
- Use `skiprows` to skip extraneous top rows that contain metadata instead of headers.
- Use `names=` if you want to override the column names entirely.

#### Wrong code

```python
# Reads the first row as header, which is wrong for this file
df = pd.read_excel('file_with_header_on_second_row.xlsx')
print(df['expected_column'])  # KeyError if expected_column was in second row
```

#### Fixed code

```python
# Option 1: specify header row where actual column names are
df = pd.read_excel('file_with_header_on_second_row.xlsx', header=1)
print(df['expected_column'])  # OK

# Option 2: skip metadata rows
df = pd.read_excel('file.xlsx', skiprows=3, header=0)

# Option 3: load with no header and set columns manually
df = pd.read_excel('file.xlsx', header=None, skiprows=3)
df.columns = ['col1', 'col2', 'expected_column']
```

### Extra tips

- For files with multi-row headers, you can pass `header=[0,1]` to get a `MultiIndex` for columns.
- Check the raw file (open it in a spreadsheet app) to find the header row and gaps, then pick the appropriate `header`/`skiprows` values. If the file is generated by another system, prefer generating clean CSVs or JSON lines where possible to reduce ambiguity in headers.
